# Copyright 2018-2025 Admenri & Contributors.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# Enhanced by AI - 2025-04-02
#
# Converts binary files into C/C++ source or header files, embedding the
# data as an array.

import sys
import os
import argparse
import textwrap
import datetime
from pathlib import Path
from typing import Optional, Sequence, TextIO

# --- Configuration ---
DEFAULT_COLUMNS = 16
DEFAULT_DATA_TYPE = "unsigned char" # Classic C
DEFAULT_LEN_TYPE = "unsigned int"   # Classic C
PREFERRED_DATA_TYPE = "uint8_t"     # Modern C/C++ (requires <stdint.h> or <cstdint>)
PREFERRED_LEN_TYPE = "size_t"       # Modern C/C++ (requires <stddef.h> or <cstddef>)

# --- Helper Functions ---

def generate_c_array_data(data: bytes, columns: int) -> str:
    """Formats the byte data into a C-style array initializer list."""
    lines = []
    line = "    "  # Initial indent
    col = 0
    for byte in data:
        line += f"0x{byte:02x},"
        col += 1
        if col >= columns:
            lines.append(line)
            line = "    "
            col = 0
        else:
            line += " " # Add space between elements unless it's the last on line

    # Add the last partially filled line if it exists and has content
    if col > 0:
        # Remove trailing comma and space if needed before adding closing brace
        lines.append(line.rstrip(", "))

    # Handle empty data case
    if not lines:
        return "{ };"

    # Join lines, ensuring proper formatting even for single-line arrays
    if len(lines) == 1:
        return "{ " + lines[0].strip() + " };"
    else:
        return "{\n" + "\n".join(lines) + "\n};"

def create_output_directory(filepath: Path):
    """Creates the directory for the output file if it doesn't exist."""
    try:
        filepath.parent.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        print(f"Error: Could not create directory '{filepath.parent}': {e}", file=sys.stderr)
        sys.exit(1)

def write_output_file(
    outfile: TextIO,
    input_filename: Path,
    symbol_name: str,
    data: bytes,
    data_type: str,
    len_type: str,
    add_null_term: bool,
    is_string: bool,
    columns: int,
    output_format: str, # 'header' or 'source'
    use_pragma_once: bool,
    use_constexpr: bool,
    use_static: bool,
    use_std_array: bool,
    namespace: Optional[str],
    alignment: Optional[int],
) -> None:
    """Writes the formatted C/C++ output to the file stream."""

    now = datetime.datetime.now(datetime.timezone.utc)
    timestamp = now.strftime("%Y-%m-%d %H:%M:%S %Z")
    original_data_len = len(data)
    output_data = data
    effective_data_len = original_data_len

    if add_null_term:
        output_data += b'\x00'
        # Length variable usually reflects data *without* null terminator
        effective_data_len = original_data_len

    # Determine effective types and qualifiers
    actual_data_type = 'char' if is_string else data_type
    len_var_type = len_type

    includes = set()
    if "int" in actual_data_type or PREFERRED_DATA_TYPE in actual_data_type:
        includes.add("<stdint.h>" if output_format == 'header' else "<cstdint>")
    if "size_t" in len_var_type or PREFERRED_LEN_TYPE in len_var_type:
        includes.add("<stddef.h>" if output_format == 'header' else "<cstddef>")
    if use_std_array:
        includes.add("<array>")
        includes.add("<cstddef>") # For size_t often used with std::array size

    # --- Header ---
    outfile.write(f"// Copyright 2018-2025 Admenri & Contributors.\n")
    outfile.write(f"// Generated by bin_to_c_converter.py on {timestamp}\n")
    outfile.write(f"// Source file: {input_filename.name}\n")
    outfile.write(f"// Data size: {original_data_len} bytes")
    if add_null_term:
        outfile.write(" (+1 null terminator)\n\n")
    else:
        outfile.write("\n\n")

    if output_format == 'header':
        if use_pragma_once:
            outfile.write("#pragma once\n\n")
        else:
            guard_symbol = f"GENERATED_{symbol_name.upper()}_H_"
            outfile.write(f"#ifndef {guard_symbol}\n")
            outfile.write(f"#define {guard_symbol}\n\n")

    for inc in sorted(list(includes)):
        outfile.write(f"#include {inc}\n")
    if includes:
        outfile.write("\n")

    # --- Namespace (Optional) ---
    if namespace:
        outfile.write(f"namespace {namespace} {{\n\n")
        indent = "    " # Add indentation within namespace
    else:
        indent = ""

    # --- Length Variable ---
    len_qualifiers = []
    if use_static and output_format == 'source': # static makes sense for source files
         len_qualifiers.append("static")
    if use_constexpr:
        len_qualifiers.append("constexpr")
    else:
        len_qualifiers.append("const") # Length is always const

    len_declaration = f"{indent}{' '.join(len_qualifiers)} {len_var_type} {symbol_name}_len = {effective_data_len};\n"

    # --- Array Variable ---
    array_qualifiers = []
    if use_static and output_format == 'source':
         array_qualifiers.append("static")
    # constexpr implies const, don't add both
    if use_constexpr and not use_std_array: # constexpr raw arrays require C++11/17 depending on context
        array_qualifiers.append("constexpr")
    elif not use_std_array: # std::array template arg handles constness
        array_qualifiers.append("const")


    # Alignment
    align_specifier = ""
    if alignment and alignment > 0:
        # C++11 alignas or C11 _Alignas
        # Assume C++ style for simplicity here, adjust if C11 needed
        align_specifier = f"alignas({alignment}) "

    # Data definition start
    array_declaration_start = f"{indent}{' '.join(array_qualifiers)} {align_specifier}"

    # Handle C-style array vs std::array
    if use_std_array:
        # std::array<type, size> name = {{ ... }};
        # Note: std::array size must be compile-time constant. constexpr len helps.
        # Requires len definition *before* array if size is derived from it (which we do).
        outfile.write(len_declaration + "\n") # Define length first for std::array size
        array_size_specifier = f"{symbol_name}_len"
        if add_null_term:
            array_size_specifier += " + 1" # Size includes null term for std::array

        # Add 'const' to the type for std::array if not constexpr
        std_array_type = f"const {actual_data_type}" if not use_constexpr else actual_data_type

        array_def = (f"{array_declaration_start} "
                     f"std::array<{std_array_type}, {array_size_specifier}> "
                     f"{symbol_name} = ")
        # std::array needs double braces {{ }} for aggregate initialization
        array_data_formatted = generate_c_array_data(output_data, columns)
        # Insert the extra brace
        if array_data_formatted.startswith("{"):
             array_data_formatted = "{" + array_data_formatted + "}";
        else: # Handle empty case
             array_data_formatted = "{{}};";

        outfile.write(array_def + array_data_formatted + "\n")

    else:
        # C-style array: type name[] = { ... }; size known implicitly or via _len
        # We can define length before or after
        array_def = (f"{array_declaration_start} "
                     f"{actual_data_type} {symbol_name}[] = ")
        array_data_formatted = generate_c_array_data(output_data, columns)
        outfile.write(array_def + array_data_formatted + "\n\n")
        outfile.write(len_declaration) # Define length after array

    # --- Namespace End (Optional) ---
    if namespace:
        outfile.write(f"\n}} // namespace {namespace}\n")

    # --- Footer ---
    if output_format == 'header' and not use_pragma_once:
        outfile.write(f"\n#endif // {guard_symbol}\n")


# --- Main Execution ---

def main(args: Optional[Sequence[str]] = None) -> int:
    """Parses arguments and orchestrates the conversion."""
    parser = argparse.ArgumentParser(
        description="Convert binary file to a C/C++ source or header file.",
        formatter_class=argparse.RawTextHelpFormatter # Preserve newline formatting in help
    )

    parser.add_argument(
        "input_file",
        type=Path,
        help="Path to the input binary file."
    )
    parser.add_argument(
        "-o", "--output",
        type=Path,
        default=None,
        help="Path to the output file.\n"
             "If omitted, defaults to '<input_file>.<ext>' where <ext> is derived\n"
             "from --format (.h or .cpp)."
    )
    parser.add_argument(
        "-s", "--symbol",
        type=str,
        default=None,
        help="C symbol name for the data array (and '_len' suffix for length).\n"
             "Defaults to a sanitized version of the input filename."
    )
    parser.add_argument(
        "--format",
        choices=['header', 'source'],
        default='header',
        help="Output file format:\n"
             "  header: Generate a .h file suitable for inclusion (default).\n"
             "  source: Generate a .c/.cpp file (definition)."
    )

    # Data Representation Options
    group_data = parser.add_argument_group('Data Representation')
    group_data.add_argument(
        "--type",
        type=str,
        default=None, # Will default later based on modern/classic preference
        help=f"C/C++ data type for the array elements.\n"
             f"Defaults: '{PREFERRED_DATA_TYPE}' (recommended) or '{DEFAULT_DATA_TYPE}'.")
    group_data.add_argument(
        "--ltype",
        type=str,
        default=None, # Will default later
        help=f"C/C++ data type for the length variable.\n"
             f"Defaults: '{PREFERRED_LEN_TYPE}' (recommended) or '{DEFAULT_LEN_TYPE}'.")
    group_data.add_argument(
        "--string",
        action='store_true',
        help="Treat data as a C string: use 'char' type and enforce null termination.\n"
             "Overrides --type and implies --null-terminated."
    )
    group_data.add_argument(
        "--null-terminated", "--null",
        action='store_true',
        help="Append a null byte (0x00) to the data.\n"
             "The '_len' variable will NOT include this null byte."
    )
    group_data.add_argument(
        "--columns",
        type=int,
        default=DEFAULT_COLUMNS,
        help=f"Number of data bytes per line in the output array (default: {DEFAULT_COLUMNS})."
    )

    # C/C++ Specific Options
    group_cpp = parser.add_argument_group('C/C++ Specific Options')
    group_cpp.add_argument(
        "--static",
        action='store_true',
        help="Declare the array and length with 'static' linkage (useful in source files\n"
             "to prevent symbol conflicts, ignored for headers)."
    )
    group_cpp.add_argument(
        "--constexpr",
        action='store_true',
        help="(C++) Declare the array and length as 'constexpr' (requires C++11/14/17).\n"
             "Implies 'const'. May not work with all types/compilers for arrays."
    )
    group_cpp.add_argument(
        "--std-array",
        action='store_true',
        help="(C++) Generate data as 'std::array' instead of a raw C array.\n"
             "Requires C++11. Automatically includes <array> and <cstddef>."
    )
    group_cpp.add_argument(
        "--namespace",
        type=str,
        default=None,
        help="(C++) Wrap the generated variables in the specified namespace."
    )
    group_cpp.add_argument(
        "--align",
        type=int,
        default=None,
        help="(C++/C11) Specify alignment requirement using 'alignas(N)'.\n"
              "Example: --align 16"
    )
    group_cpp.add_argument(
        "--no-pragma-once",
        action='store_true',
        help="Use traditional #ifndef/#define include guards instead of #pragma once\n"
             "for header files."
    )
    group_cpp.add_argument(
        "--use-classic-types",
        action='store_true',
        help=f"Prefer classic C types ('{DEFAULT_DATA_TYPE}', '{DEFAULT_LEN_TYPE}')\n"
             f"instead of modern standard types ('{PREFERRED_DATA_TYPE}', '{PREFERRED_LEN_TYPE}')."
    )

    parser.add_argument(
        "-v", "--version",
        action='version',
        version='%(prog)s 2.0 Enhanced'
    )

    parsed_args = parser.parse_args(args) # Use provided args for testing, or sys.argv[1:]

    # --- Argument Validation and Post-processing ---
    input_file: Path = parsed_args.input_file
    if not input_file.is_file():
        parser.error(f"Input file not found or is not a file: {input_file}")

    # Determine output filename
    output_file: Path = parsed_args.output
    if not output_file:
        default_ext = '.h' if parsed_args.format == 'header' else '.cpp' # Assume C++ for source default
        output_file = input_file.with_suffix(f"{input_file.suffix}{default_ext}")

    # Determine symbol name
    symbol_name: str = parsed_args.symbol
    if not symbol_name:
        # Sanitize input filename for use as a C identifier
        base = input_file.stem.replace('.', '_').replace('-', '_').replace(' ', '_')
        # Ensure it starts with a letter or underscore
        if not base or not (base[0].isalpha() or base[0] == '_'):
            base = '_' + base
        # Remove invalid characters (allow letters, numbers, underscore)
        symbol_name = "".join(c for c in base if c.isalnum() or c == '_')
        if not symbol_name: # Fallback if sanitation removed everything
            symbol_name = "embedded_data"

    # Handle --string implications
    is_string = parsed_args.string
    null_terminate = parsed_args.null_terminated or is_string

    # Determine data/length types (prefer modern unless overridden)
    data_type = parsed_args.type
    if not data_type:
        data_type = DEFAULT_DATA_TYPE if parsed_args.use_classic_types else PREFERRED_DATA_TYPE

    len_type = parsed_args.ltype
    if not len_type:
        len_type = DEFAULT_LEN_TYPE if parsed_args.use_classic_types else PREFERRED_LEN_TYPE

    # Final checks
    if parsed_args.constexpr and parsed_args.static:
         print("Warning: Using both --constexpr and --static. 'constexpr' usually implies internal linkage (like static) in C++.", file=sys.stderr)
    if parsed_args.format == 'header' and parsed_args.static:
         print("Warning: --static has no effect for --format=header.", file=sys.stderr)
    if parsed_args.std_array and parsed_args.format == 'header' and not parsed_args.constexpr:
         print("Warning: Using --std-array in a header without --constexpr might lead to Multiple Definition Errors if included in multiple source files. Consider using --constexpr or --format=source.", file=sys.stderr)
    if parsed_args.align is not None and parsed_args.align <= 0:
        parser.error("--align value must be positive.")

    # --- Read Input ---
    try:
        input_data = input_file.read_bytes()
    except IOError as e:
        print(f"Error: Failed to read input file '{input_file}': {e}", file=sys.stderr)
        return 1

    # --- Generate Output ---
    create_output_directory(output_file)

    try:
        with open(output_file, 'w', encoding='utf-8') as outfile:
            write_output_file(
                outfile=outfile,
                input_filename=input_file,
                symbol_name=symbol_name,
                data=input_data,
                data_type=data_type,
                len_type=len_type,
                add_null_term=null_terminate,
                is_string=is_string,
                columns=parsed_args.columns,
                output_format=parsed_args.format,
                use_pragma_once=not parsed_args.no_pragma_once,
                use_constexpr=parsed_args.constexpr,
                use_static=parsed_args.static,
                use_std_array=parsed_args.std_array,
                namespace=parsed_args.namespace,
                alignment=parsed_args.align,
            )
        print(f"Successfully generated '{output_file}' from '{input_file}'.")
        print(f"  Symbol: {symbol_name}[], {symbol_name}_len")
        print(f"  Format: {parsed_args.format}, Type: {'char' if is_string else data_type}")

    except IOError as e:
        print(f"Error: Failed to write output file '{output_file}': {e}", file=sys.stderr)
        return 1
    except Exception as e:
        # Catch unexpected errors during generation
        print(f"An unexpected error occurred: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1

    return 0

if __name__ == '__main__':
    sys.exit(main())
